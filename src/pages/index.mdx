# Introduction

Aiken is a new programming language and toolchain for developing smart
contracts on the [Cardano](https://cardano.org) blockchain.

This page gives an overview of the project goals and values, as well an idea of
the roadmap we're pursuing. The rest of the book contains useful information
for getting started with and deep diving into Aiken (both the language, and the
toolkit).

Welcome, and enjoy.

## Philosophy

Our main goal is to improve the smart contract development experience for the
Cardano blockchain. Aiken takes inspiration from many modern languages such as
Gleam, Rust, and Elm which are known for friendly error messages and an overall
excellent developer experience. We believe Cardano deserves a dedicated
language with these kinds of features, developed in the open with the
community.

Hence, Aiken is not intended as a general purpose language. Rather, it is
bespoke to Cardano, and aim at delivering high-quality tools for writing
Cardano smart contracts.

## Goals

1. Writing smart contracts should be easy and safe. You should be able to get
started in minutes not days, and rapidly build confidence that your on-chain
code is doing what is intended.

2. We want a complete and delightful experience. A modern blockchain deserves a
modern smart contract toolkit. You should feel productive when writing
contracts. This includes editor integrations such as LSP and tree-sitter along
with beautiful error messages, rapid and intuitive test feedback loop and a
documentation that is easy to produce and consume.

3. We want there to be as little configuration as possible. It should work out
of the box and have opinionated reasonable conventions established with the
community.

4. We want to have a modular design so that components can be picked and chosen
as needed. Like the unix philosophy. Aiken is only one part of a much bigger
picture; while we firmly believe it is a great tool, we do want to embrace
other approaches and favor interoperability as much as possible.

## Roadmap

### Alpha release

At first, we want Aiken to be usable and somewhat demonstrates our goals and
values above. The _Alpha release_ of Aiken will include a proof-of-concept
toolkit and language, as well as everything that we deem necessary to
conformtably and confidently write smart-contracts for Cardano.

#### ü™®  Foundation

- [x] Bare minimum toolkit for working with untyped Plutus core (a.k.a UPLC)
- [x] Serialization of Plutus core into it's on chain encoding
- [x] Deserialization of on-chain encoding into Plutus core model
- [x] Plutus Core interpreter
- [x] UPLC code formatter

#### üöÄ [Language PoC](https://github.com/txpipe/aiken/milestone/1)

- [x] Define Aiken as a language, purely function, statically typed. Keep it simple.
- [x] Implement lexing/parsing with pretty error messages
- [x] Type checking, inference and helpful compiler errors.
- [ ] Optimized UPLC code generation
- [ ] Project dependencies, packages and ecosystem base tooling

#### üìê [Standard library](https://github.com/txpipe/aiken/milestone/2)

- [ ] Written and tested in Aiken, in progress on [aiken-lang/stdlib](https://github.com/aiken-lang/stdlib)
- [x] Parsing, rendering and hosting Aiken's documentation for beautful libraries (`aiken docs`)

#### üî¨ [Testing Framework](https://github.com/txpipe/aiken/milestone/4)

- [x] Integrated testing framework, with monitoring of execution units
- [x] Automatic diffing of test predicates, with pretty rendering

#### üé® [Improved Tooling](https://github.com/txpipe/aiken/milestone/3)

- [x] Code formatter
- [x] Syntax highlighting plugins for editors
- [x] LSP

### Beta release

The _Beta release_ will sign Aiken's production readiness. We'll have addressed shortcomings identified during the Alpha and make final decision regarding some design elements. Plus, we'll keep on improving tooling and overall maturity of the project.

- [ ] Finalized language & standard library
- [ ] Online playground
- [ ] Executable snippets of code in browser's documentation
- [ ] Property-based testing with integrated shrinking and automatic generator
- [ ] More complete LSP features
- [ ] End-to-end reference examples of non-trivial DApps
- [ ] More UPLC optimizations
- [ ] External audit
